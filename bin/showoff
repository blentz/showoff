#! /usr/bin/env ruby

$LOAD_PATH.unshift File.join(File.dirname(__FILE__), '..', 'lib')
require 'showoff/version'
require 'rubygems'
require 'fidget'
require 'gli'

# See https://github.com/davetron5000/gli/issues/196 for rationale for this silly wrapper
module Wrapper
  include GLI::App
  extend self

  version SHOWOFF_VERSION
  program_desc <<-desc
  A web based presentation engine with awesome interaction features.

    Showoff uses Markdown files with a few custom extensions to generate slides
    that are served locally for presentation via web browser. Your audience can
    view presentations directly as well, and interact with you in many ways.

    Showoff can optionally use the PDFKit gem to autogenerate PDF files on demand.
    Viewers can access the /pdf endpoint to download a generated PDF file. This
    functionality is likely to be deprecated, since it is simpler and easier to
    just print the /print endpoint directly from your browser.

    The simplest use case is to run `showoff serve` from the directory containing
    the showoff.json file.
  desc
  switch :debug, :desc => "Show application backtraces on crash"

  desc 'Create new showoff presentation'
  long_desc 'This command helps start a new showoff presentation by setting up the proper directory structure for you.  It takes the directory name you would like showoff to create for you.'
  command [:create,:init] do |c|

    c.desc 'Don''t create sample slides'
    c.switch [:n,:nosamples]

    c.desc 'Comma separated list of initial slide directory name(s).'
    c.default_value 'one'
    c.flag [:d,:slidedir]

    c.action do |global_options,options,args|
      dir_name = args.first || '.'
      ShowoffUtils.create(dir_name,!options[:n],options[:d])
      if options[:n]
        puts "Add slides and update #{dir_name}/#{ShowoffUtils.presentation_config_file}"
      end
      if args.empty?
        puts "Run 'showoff serve' to see your new slideshow"
      else
        puts "Run 'showoff serve' in the #{dir_name} directory to see your new slideshow"
      end
    end
  end

  desc 'Build a showoff presentation from a showoff.json outline'
  long_desc 'This command helps start a new showoff presentation by creating each slide listing in the showoff.json file.'
  command [:skeleton] do |c|

    c.desc 'alternate json filename'
    c.flag [:f,:file]

    c.action do |global_options,options,args|
      ShowoffUtils.skeleton(options[:f])
      puts "done. run 'showoff serve' to see your slideshow"
    end
  end

  desc 'Display information about a Showoff presentation'
  long_desc 'This command compiles the presentation, then lists out all Markdown files, images, stylesheets, and javascripts included.'
  command [:info] do |c|

    c.desc 'alternate json filename'
    c.flag [:f,:file]

    c.desc 'render output as json'
    c.switch [:j,:json]

    c.action do |global_options,options,args|
      begin
        # Load config
        config_file = options[:f] || ShowoffUtils.presentation_config_file
        Showoff::Config.load(config_file)

        # Get presentation info
        title = Showoff::Config.get('name') || "Untitled Presentation"

        # Collect information
        data = {}
        data['files'] = Showoff::Config.sections.values.flatten
        data['styles'] = Dir.glob("#{Showoff::Config.root}/*.css").map { |path| File.basename(path) }
        data['scripts'] = Dir.glob("#{Showoff::Config.root}/*.js").map { |path| File.basename(path) }

        # Find images in HTML files
        data['images'] = []
        data['files'].each do |file|
          file_path = File.join(Showoff::Config.root, file)
          if File.exist?(file_path) && File.extname(file) == '.md'
            content = File.read(file_path)
            # Simple regex to find image references in markdown
            content.scan(/!\[.*?\]\((.*?)\)/).each do |match|
              data['images'] << match[0]
            end
          end
        end

        # Now grep through the styles and identify referenced images
        data['styles'].each do |style|
          style_path = File.join(Showoff::Config.root, style)
          if File.exist?(style_path)
            File.readlines(style_path).each do |line|
              next unless line =~ /url\(\'(\S+)\'\)/
              data['images'] << $1
            end
          end
        end

        # Make sure images are unique
        data['images'].uniq!

        # Output the information
        if options[:j]
          puts JSON.pretty_generate(data)
        else
          puts "Presentation: #{title}"
          puts "Slides: #{data['files'].length}"
          puts

          data.each do |key, list|
            puts "#{key.capitalize}:"
            list.each {|file| puts "    * #{file}" }
            puts
          end
        end
      rescue => e
        puts "Error: #{e.message}"
        puts e.backtrace.join("\n")
      end
    end
  end

  desc 'Validate the consistency of your presentation.'
  long_desc 'This ensures that each file listed in showoff.json exists and validates code blocks on each slide.'
  command [:validate] do |c|

    c.desc 'alternate json filename'
    c.flag [:f,:file]

    c.action do |global_options,options,args|
      require 'showoff_ng'
      require 'showoff/compiler'
      require 'showoff/presentation'
      require 'tempfile'
      require 'nokogiri'

      # Load config
      config_file = options[:f] || ShowoffUtils.presentation_config_file
      Showoff::Config.load(config_file)

      # Set content locale
      Showoff::Locale.setContentLocale(nil)

      # Get validators from config
      validators = Showoff::Config.get('validators') || {}
      files = []
      errors = []

      # Get a list of actual filenames
      files = ShowoffUtils.showoff_slide_files('.')
      files.each do |filename|
        unless File.exist? filename
          errors << "Missing path: #{filename}"
          next
        end

        if filename.downcase.end_with? '.md'
          print '.'

          # Read file content
          content = File.read(filename)

          # Use a simpler approach to extract code blocks
          # This regex matches code blocks in markdown: ```language\ncode\n```
          code_blocks = []
          content.scan(/```(\w+)(.*?)```/m).each_with_index do |(lang, code), index|
            code_blocks << [lang, code.strip, []]
          end

          # Also look for indented code blocks with language specifiers
          content.scan(/\n    @@@\s*(\w+)(.*?)(?:\n\n|\z)/m).each_with_index do |(lang, code), index|
            code_blocks << [lang, code.strip.gsub(/^    /, ''), []]
          end

          # Create a simple HTML document with code blocks
          html = "<html><body>"
          code_blocks.each do |lang, code, _|
            html += "<pre><code class=\"language-#{lang}\">#{code}</code></pre>"
          end
          html += "</body></html>"

          # Parse HTML
          doc = Nokogiri::HTML(html)

          # Extract code blocks
          doc.css('pre code').each_with_index do |code_block, index|
            # Get language from class
            lang = nil
            classes = code_block['class'].to_s.split
            classes.each do |cls|
              if cls =~ /language-(\w+)/
                lang = $1
                break
              end
            end

            # Get code
            code = code_block.text

            # Skip validation if marked as no-validate
            if classes.include? 'no-validate'
              print '-'
              next
            end

            # Validate if we have a validator for this language
            validator = validators[lang]
            if validator
              # Write to temp file and validate
              Tempfile.open('showoff-validation') do |f|
                File.write(f.path, code)
                unless system("#{validator} #{f.path}", :out => File::NULL, :err => File::NULL)
                  print 'F'
                  errors << "Invalid #{lang} code on #{filename} [#{index}]"
                end
              end
            end
          end
        end
      end

      puts
      puts "Found #{errors.size} errors."
      unless errors.empty?
        errors.each { |err| puts " * #{err}" }
        exit 1
      end
    end
  end

  desc 'Puts your showoff presentation into a gh-pages branch'
  long_desc 'Generates a static version of your presentation into your gh-pages branch for publishing to GitHub Pages'
  command :github do |c|
    c.action do |global_options,options,args|
      puts "Generating static content"
      ShowoffUtils.github
      puts "I've updated your 'gh-pages' branch with the static version of your presentation."
      puts "Push it to GitHub to publish it. Probably something like:"
      puts
      puts "  git push origin gh-pages"
      puts
    end
  end

  desc 'Serves the showoff presentation in the current directory'
  desc 'Generate Heroku deployment files'
  arg_name 'heroku_name'
  long_desc 'Creates the configuration files needed for Heroku deployment. This command only generates files and does not require the heroku CLI or network access.'
  command :heroku do |c|

    c.desc 'add password protection to your heroku site'
    c.flag [:p,:password]

    c.desc 'force overwrite of existing Gemfile/.gems and config.ru files if they exist'
    c.switch [:f,:force]

    c.action do |global_options,options,args|
      raise "heroku_name is required" if args.empty?
      raise "Name must start with a letter and can only contain lowercase letters, numbers, and dashes." unless args.first =~ /^[a-z][a-z1-9-]*$/

      # Generate the files
      if ShowoffUtils.heroku(args[0], options[:p], options[:f])
        puts "Heroku configuration files generated:"
        puts " * Procfile"
        puts " * Gemfile"
        puts " * config.ru"
        puts
        puts "To deploy to Heroku:"
        puts "  1. Install the Heroku CLI if not already installed"
        puts "  2. Login with 'heroku login'"
        puts "  3. Initialize git if needed: 'git init'"
        puts "  4. Create Heroku app: 'heroku create #{args[0]}'"
        puts "  5. Add files: 'git add Procfile Gemfile config.ru'"
        puts "  6. Commit files: 'git commit -m \"Heroku configuration\"'"
        puts "  7. Deploy: 'git push heroku main'"
        puts
        if options[:p]
          puts "CAREFUL: you are including your access password in config.ru"
          puts "Anyone with read access to the repo can access the presentation"
          puts
        end
      end
    end
  end

  desc 'Serves the showoff presentation in the specified (or current) directory'
  arg_name "[pres_dir]"
  default_value "."
  long_desc <<-EOS
Starts a web server to display your presentation. By default, the server
runs on http://0.0.0.0:9090

Options:
EOS
  command :serve do |c|

    c.desc 'Show verbose messaging'
    c.switch [:v, :verbose]

    c.desc 'Enable code review'
    c.switch [:r, :review]

    c.desc 'Enable remote code execution'
    c.switch [:x, :execute, :executecode]

    c.desc 'Run in standalone mode, with no audience interaction'
    c.switch [:S, :standalone]

    c.desc 'Disable content caching'
    c.switch :nocache

    c.desc 'Prevent the computer from sleeping during your presentation'
    c.switch :nosleep

    c.desc 'Port on which to run'
    c.default_value "9090"
    c.flag [:p, :port]

    c.desc 'Host or ip to run on'
    c.default_value "0.0.0.0"
    c.flag [:h, :host]

    c.desc 'Run via HTTPS'
    c.switch [:s, :ssl]

    c.desc 'Path to SSL certificate'
    c.flag :ssl_certificate

    c.desc 'Path to SSL private key'
    c.flag :ssl_private_key

    c.desc 'JSON file used to describe presentation'
    c.default_value "showoff.json"
    c.flag [:f, :file, :pres_file]

    c.desc 'Git URL to a repository containing the presentation'
    c.flag [:u, :url, :git_url]

    c.desc 'Branch of the git repository to use'
    c.flag [:git_branch]

    c.desc 'Path of the presentation within the git repository'
    c.flag [:git_path]

    c.action do |global_options,options,args|

      # Load configuration from showoff.json
      config = JSON.parse(File.read(options[:f])) rescue {}
      if Gem::Version.new(config['version'].to_s) > Gem::Version.new(SHOWOFF_VERSION) then
        raise "This presentation requires Showoff version #{config['version']} or greater."
      end

      options[:host]            ||= config['host']
      options[:port]            ||= config['port']
      options[:ssl]             ||= config['ssl']
      options[:ssl_certificate] ||= config['ssl_certificate']
      options[:ssl_private_key] ||= config['ssl_private_key']
      options[:standalone]      ||= config['standalone']

      options[:pres_dir]          = args[0]
      options[:port]              = options[:port].to_i
      options[:bind]              = options[:host]

      ssl_options = {
        :cert_chain_file  => options[:ssl_certificate],
        :private_key_file => options[:ssl_private_key],
        :verify_peer      => false,
      }

      protocol = options[:ssl] ? 'https' : 'http'
      host     = options[:host] == '0.0.0.0' ? 'localhost' : options[:host]
      url      = "#{protocol}://#{host}:#{options[:p].to_i}"
      puts "
  -------------------------

  Your Showoff presentation is now starting up.

  To view it plainly, visit [ #{url} ]

  To run it from presenter view, go to: [ #{url}/presenter ]

  -------------------------

  "

      if options[:nosleep] and Fidget.current_process
        puts '**** System sleep has been suspended. ****'
        puts
      end

      # Helper method to configure SSL
      configure_ssl = lambda do |server, opts|
        if opts[:ssl]
          server.ssl = true
          server.ssl_options = ssl_options
        end
      end

        # Normalize options (similar to what ServerAdapter did)
        normalized_options = {
          pres_dir: options[:pres_dir] || '.',
          pres_file: options[:f] || options[:file] || options[:pres_file] || 'showoff.json',
          verbose: options[:v] || options[:verbose] || false,
          execute: options[:x] || options[:execute] || options[:executecode] || false,
          review: options[:r] || options[:review] || false,
          standalone: options[:S] || options[:standalone] || false,
          nocache: options[:nocache] || false,
          bind: options[:bind] || options[:host] || options[:h] || '0.0.0.0',
          port: options[:p] || options[:port] || 9090
        }

        # Start the server
        if options[:url]
          # Git repository handling
          ShowoffUtils.clone(options[:git_url], options[:git_branch], options[:git_path]) do
            # Set options on the class
            Showoff::Server.set :pres_dir, normalized_options[:pres_dir]
            Showoff::Server.set :pres_file, normalized_options[:pres_file]
            Showoff::Server.set :verbose, normalized_options[:verbose]
            Showoff::Server.set :execute, normalized_options[:execute]
            Showoff::Server.set :review, normalized_options[:review]
            Showoff::Server.set :standalone, normalized_options[:standalone]
            Showoff::Server.set :nocache, normalized_options[:nocache]

            # Configure SSL if needed
            if options[:ssl]
              Showoff::Server.set :ssl, true
              Showoff::Server.set :ssl_options, ssl_options
            end

            # Run the server using class method
            Showoff::Server.run!(
              bind: normalized_options[:bind],
              port: normalized_options[:port].to_i
            )
          end
        else
          # Direct invocation
          # Set options on the class
          Showoff::Server.set :pres_dir, normalized_options[:pres_dir]
          Showoff::Server.set :pres_file, normalized_options[:pres_file]
          Showoff::Server.set :verbose, normalized_options[:verbose]
          Showoff::Server.set :execute, normalized_options[:execute]
          Showoff::Server.set :review, normalized_options[:review]
          Showoff::Server.set :standalone, normalized_options[:standalone]
          Showoff::Server.set :nocache, normalized_options[:nocache]

          # Configure SSL if needed
          if options[:ssl]
            Showoff::Server.set :ssl, true
            Showoff::Server.set :ssl_options, ssl_options
          end

          # Run the server using class method
          Showoff::Server.run!(
            bind: normalized_options[:bind],
            port: normalized_options[:port].to_i
          )
        end

    end
  end

  desc 'Add a new slide at the end in a given dir'
  arg_name '[title]'
  long_desc 'Outputs or creates a new slide.  With -d and -n, a new slide is created in the given dir, numbered to appear as the last slide in that dir (use -u to avoid numbering).  Without those, outputs the slide markdown to stdout (useful for shelling out from your editor). You may also specify a source file to use for a code slide'
  command [:add,:new] do |c|
    c.desc 'Don''t number the slide, use the given name verbatim'
    c.switch [:u,:nonumber]

    c.desc 'Include code from the given file as the slide body'
    c.arg_name 'path to file'
    c.flag [:s,:source]

    c.desc 'Slide Type/Style'
    c.arg_name 'valid showoff style/type'
    c.default_value 'title'
    c.flag [:t,:type,:style]

    c.desc 'Slide dir (where to put a new slide file)'
    c.arg_name 'dir'
    c.flag [:d,:dir]

    c.desc 'Slide name (name of the new slide file)'
    c.arg_name 'basename'
    c.flag [:n,:name]

    c.action do |global_options,options,args|
      title = args.join(" ")
      ShowoffUtils.add_slide(:dir => options[:d],
                             :name => options[:n],
                             :title => title,
                             :number => !options[:u],
                             :code => options[:s],
                             :type => options[:t])
    end
  end

  desc 'Generate static version of presentation'
  arg_name 'name'
  long_desc 'Creates a static, one page version of the presentation as {name}.html'
  command [:static] do |c|
    c.desc 'JSON file used to describe presentation'
    c.default_value "showoff.json"
    c.flag [:f, :file, :pres_file]

    c.desc 'Language code to generate.'
    c.flag [:l, :lang, :language, :locale]

    c.action do |global_options,options,args|
      Showoff.do_static(args, options)
    end
  end

  desc 'Generate PDF version of presentation'
  arg_name 'name'
  long_desc 'Creates a PDF version of the presentation as {name}.pdf'
  command [:pdf] do |c|
    c.desc 'JSON file used to describe presentation'
    c.default_value "showoff.json"
    c.flag [:f, :file, :pres_file]

    c.desc 'Language code to generate.'
    c.flag [:l, :lang, :language, :locale]

    c.action do |global_options,options,args|
      Showoff.do_static(['pdf'].concat(args), options)
    end
  end

  pre do |global,command,options,args|
    # Pre logic here
    # Return true to proceed; false to abort and not call the
    # chosen command

    if global[:debug]
      ENV['GLI_DEBUG'] = 'true'
    end

    # Load required libraries based on command
    case command.name.to_s
    when 'static', 'pdf'
      require 'showoff_ng'
      if options[:file]
        Showoff::Config.load(options[:file])
      end
    when 'serve'
      require 'showoff_ng'
      require 'showoff/server'
    when 'info', 'validate'
      require 'showoff_ng'
      require 'showoff_utils'
      require 'nokogiri'
      require 'json'
    else
      # Other commands use showoff_utils
      require 'showoff_utils'
    end

    true
  end

  post do |global,command,options,args|
    # Post logic here
  end

  on_error do |exception|
    # Error logic here
    # return false to skip default error handling
    true
  end

  # start the application
  exit run(ARGV)
end
